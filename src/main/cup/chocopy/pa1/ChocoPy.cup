import java.util.*;
import java_cup.runtime.*;
import chocopy.common.astnodes.*;

/* The following code section is copied verbatim to the generated parser class. */
parser code {:


    // The following fields and methods deal with error reporting
    // Avoid changing these unless you know what you are doing

    public final Errors errors = new Errors(new ArrayList<>());

    @Override
    public SymbolFactory getSymbolFactory() {
        return ((ChocoPyLexer) getScanner()).symbolFactory;
    }

    @Override
    public void syntax_error(Symbol cur_token) {
                String token = symbl_name_from_id(cur_token.sym);
                String text = ((ChocoPyLexer) getScanner()).yytext();
                errors.add(new SyntaxError(
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xleft,
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xright,
                    String.format("Parse error near token %s: %s", token, text)));
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        // Do not die
    }
:}


/**************************************************************************
 *              FEEL FREE TO MODIFY ANYTHING BELOW THIS LINE              
 *
 * The provided rules parse expressions of the form <INT> + <INT> + ... 
 * You can re-use these rules or edit them as you wish. The start rule
 * should return a node of type Program.
 *
 *
 * Tips: Production rules are usually followed by action code that will be
 * copied to the generated parser to be executed immediately after a reduce
 * operation; that is, when a production rule has been matched. You can name
 * a nonterminal or terminal symbol in a production rule using the colon
 * notation, e.g. expr_stmt ::= expr:e, to get the AST node for the matched
 * expression. In the action code, `e` will be a variable of whatever type
 * has been declared for the corresponding nonterminal, such as `Expr`.
 * Therefore, you can construct an AST Node of type `ExprStmt` with `e` in the
 * constructor: `new ExprStmt(exleft, exright, e)`
 *
 * The variables `exleft` and `exright` are automatically generated by CUP
 * and contain Location objects for the start and end of the expression `e`.
 * You can collect start and line number info for AST nodes by taking the
 * left-location of the left-most symbol in a rule and the right-location of the
 * right-most symbol. The auto-generated variables have names `<sym>xleft`
 * and `<sym>xright` where <sym> is the name given to the symbol using the
 * colon notation.
 **************************************************************************/


/* The following code section is copied verbatim to the class which performs actions on REDUCE. */
action code {:

    // You can define Java methods here that
    // can be used within the grammar rule actions.

    // Here are some useful methods to make lists of things
    // when implementing the kleene star

    <T> List<T> single(T item) {
        List<T> list = new ArrayList<>();
        list.add(item);
        return list;
    }

    <T> List<T> combine(List<T> list, T item) {
        list.add(item);
        return list;
    }

    <T> List<T> empty() {
        return new ArrayList<T>();
    }
:}

/* Declaration of terminal symbols (tokens returned by the lexer) */
terminal NEWLINE;         // the type does not matter because we discard the value
terminal String PLUS;     // the lexer provides a value of type `String`
terminal Integer NUMBER;  // the lexer provides a value of type `Integer`
terminal UNRECOGNIZED;    // produced by the lexer on error; no syntax rule should contain this token

/* Declaration of nonterminal symbols (defined in production rules below) */
non terminal Program           program;
non terminal List<Declaration> top_level_decl;
non terminal List<Stmt>        stmt_list;
non terminal Stmt              stmt, expr_stmt;
non terminal Expr              expr, binary_expr;

/* Precedences */
precedence left PLUS;

/* Declare the start rule */
start with program;



/* The grammar rules */
program ::= top_level_decl:d stmt_list:s   {: RESULT = new Program(dxleft, sxright, d, s); :}
          ;

top_level_decl ::= /* not implemented; matches empty string */ {: RESULT = empty(); :}
                ;

stmt_list ::= stmt:s                 {: RESULT = single(s); :}
            | stmt_list:l stmt:s     {: RESULT = combine(l, s); :}
            | stmt_list:l error      {: RESULT = l; :}   /* recovers from syntax errors in a stmt and moves on */
            ;

stmt ::= expr_stmt:s NEWLINE   {: RESULT = s; :}
              ;

expr_stmt ::= expr:e       {: RESULT = new ExprStmt(exleft, exright, e); :}
            ;

expr ::= binary_expr:e     {: RESULT = e; :}
       | NUMBER:n          {: RESULT = new IntegerLiteral(nxleft, nxright, n); :}
       ;


binary_expr ::= expr:e1 PLUS:op expr:e2         {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              ;
/* Observe how the left and right source code locations are collected from e1 and e2 */
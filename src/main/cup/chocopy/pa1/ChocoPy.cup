import java.util.*;
import java_cup.runtime.*;
import chocopy.common.astnodes.*;

/* The following code section is copied verbatim to the generated parser class. */
parser code {:


    // The following fields and methods deal with error reporting
    // Avoid changing these unless you know what you are doing

    public final Errors errors = new Errors(new ArrayList<>());

    @Override
    public SymbolFactory getSymbolFactory() {
        return ((ChocoPyLexer) getScanner()).symbolFactory;
    }

    @Override
    public void syntax_error(Symbol cur_token) {
                String token = symbl_name_from_id(cur_token.sym);
                String text = ((ChocoPyLexer) getScanner()).yytext();
                errors.add(new SyntaxError(
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xleft,
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xright,
                    String.format("Parse error near token %s: %s", token, text)));
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        // Do not die
    }
:}


/**************************************************************************
 *              FEEL FREE TO MODIFY ANYTHING BELOW THIS LINE              
 *
 * The provided rules parse expressions of the form <INT> + <INT> + ... 
 * You can re-use these rules or edit them as you wish. The start rule
 * should return a node of type Program.
 *
 *
 * Tips: Production rules are usually followed by action code that will be
 * copied to the generated parser to be executed immediately after a reduce
 * operation; that is, when a production rule has been matched. You can name
 * a nonterminal or terminal symbol in a production rule using the colon
 * notation, e.g. expr_stmt ::= expr:e, to get the AST node for the matched
 * expression. In the action code, `e` will be a variable of whatever type
 * has been declared for the corresponding nonterminal, such as `Expr`.
 * Therefore, you can construct an AST Node of type `ExprStmt` with `e` in the
 * constructor: `new ExprStmt(exleft, exright, e)`
 *
 * The variables `exleft` and `exright` are automatically generated by CUP
 * and contain Location objects for the start and end of the expression `e`.
 * You can collect start and line number info for AST nodes by taking the
 * left-location of the left-most symbol in a rule and the right-location of the
 * right-most symbol. The auto-generated variables have names `<sym>xleft`
 * and `<sym>xright` where <sym> is the name given to the symbol using the
 * colon notation.
 *
 * When you have nonterminals that are lists of things, e.g. List<Stmt> or
 * List<Declaration>, it is helpful to get the leftmost and rightmost
 * source location from within this list; we have provided some utility
 * functions below to do just that.
 **************************************************************************/


/* The following code section is copied verbatim to the class which performs actions on REDUCE. */
action code {:

    // You can define Java methods here that
    // can be used within the grammar rule actions.

    // Here are some useful methods to make lists of things
    // when implementing the kleene star

    <T> List<T> single(T item) {
        List<T> list = new ArrayList<>();
        list.add(item);
        return list;
    }

    <T> List<T> combine(List<T> list, T item) {
        list.add(item);
        return list;
    }

    <T> List<T> empty() {
        return new ArrayList<T>();
    }

    // Gets the leftmost non-whitespace location in a list of nodes (e.g. a block of statements)
    ComplexSymbolFactory.Location getLeft(List<? extends Node> nodes) {
        Node first = nodes.get(0);
        return new ComplexSymbolFactory.Location(first.getLocation()[0], first.getLocation()[1]);
    }

    // Gets the rightmost non-whitespace location in a list of nodes (e.g. a block of statements)
    ComplexSymbolFactory.Location getRight(List<? extends Node> nodes) {
        Node last = nodes.get(nodes.size()-1);
        return new ComplexSymbolFactory.Location(last.getLocation()[2], last.getLocation()[3]);
    }
:}

/* Declaration of terminal symbols (tokens returned by the lexer) */
terminal NEWLINE;         // the type does not matter because we discard the value
terminal String PLUS;     // the lexer provides a value of type `String`
terminal String MINUS;    // the lexer provides a value of type `String`
terminal String MULT;    // the lexer provides a value of type `String`
terminal String INTDIV;    // the lexer provides a value of type `String`
terminal String MOD;    // the lexer provides a value of type `String`


terminal String LTHAN;    // the lexer provides a value of type `String`
terminal String GTHAN;    // the lexer provides a value of type `String`
terminal String LEQ;    // the lexer provides a value of type `String`
terminal String GEQ;    // the lexer provides a value of type `String`
terminal String EQUALSEQUALS;    // the lexer provides a value of type `String`
terminal String NOTEQUALS;    // the lexer provides a value of type `String`
terminal String EQUALS;    // the lexer provides a value of type `String`
terminal String COLON;
terminal String PERIOD;
terminal String RARROW;
terminal INDENT;
terminal DEDENT;





terminal String LPAREN;   // terminal for parenthesis "("
terminal String RPAREN;   // terminal for parenthesis ")"
terminal String LBRACK;   // terminal for square bracket "["
terminal String RBRACK;   // terminal for square bracket "]"
terminal String COMMA;    // terminal for comma
terminal Integer NUMBER;  // the lexer provides a value of type `Integer`
terminal String STRING;   // the STRING Literal
terminal String ID;       //
terminal boolean BOOL;
terminal UNRECOGNIZED;    // produced by the lexer on error; no syntax rule should contain this token

/* Terminal Keywords */
terminal NONE;
terminal AND;
terminal AS;
terminal CLASS;
terminal DEF;
terminal ELIF;
terminal ELSE;
terminal FOR;
terminal GLOBAL;
terminal IF;
terminal IN;
terminal IS;
terminal NONLOCAL;
terminal NOT;
terminal OR;
terminal PASS;
terminal RETURN;
terminal WHILE;
terminal String UNUSED;    // reserved but unused keywords

/* Declaration of nonterminal symbols (defined in production rules below) */
non terminal Program           program;
non terminal ClassDef          class_def;
non terminal GlobalDecl        global_decl;
non terminal TypedVar          typed_var;
non terminal List<TypedVar>    typed_var_list, tvlh;
non terminal TypeAnnotation    type;
non terminal List<Declaration> top_level_decl, declaration_list, class_helper;
non terminal List<Stmt>        stmt_list, elif_list, optionalElse, block;
non terminal Stmt              stmt, expr_stmt, elif_block;
non terminal Expr              expr, binary_expr,optionalRet, assign_expr;
non terminal IndexExpr         index_expr;
non terminal MemberExpr        member_expr;
non terminal List<Expr>        list_expr;
non terminal Literal           literal;
non terminal Identifier        identifier;
non terminal VarDef            var_def;
non terminal FuncDef           func_def;

/* Precedences */
precedence left OR;
precedence left AND;
precedence left NOT;
precedence nonassoc EQUALSEQUALS, NOTEQUALS, GTHAN, GEQ, LTHAN, LEQ, IS;
precedence left PLUS, MINUS;
precedence left MULT, INTDIV, MOD;
precedence left PERIOD, COMMA, LBRACK, RBRACK, LPAREN;
precedence left ELIF;

/* Declare the start rule */
start with program;

/* The grammar rules */
program ::= top_level_decl:d stmt_list:s   {: RESULT = new Program(d.isEmpty() ? getLeft(s) : getLeft(d), getRight(s), d, s); :}
          ;
//HELPER SYMBOL FOR [stmt]+
stmt_list ::= stmt:s                 {: RESULT = single(s); :}
            | stmt_list:l stmt:s     {: RESULT = combine(l, s); :}
            | stmt_list:l error      {: RESULT = l; :}   /* recovers from syntax errors in a stmt and moves on */
            ;
//HELPER SYMBOL FOR [var_def | func_def | class_def]*
top_level_decl ::= top_level_decl:tld var_def:vd  {: RESULT = combine(tld, vd); :}
                 //| top_level_decl:tld func_def:vd  {: RESULT = empty(); :}
                 //| top_level_decl:tld class_def:vd  {: RESULT = empty(); :}
                 |                                {: RESULT = empty(); :}
                ;
                
func_def ::= DEF:def identifier:id LPAREN typed_var_list:tvl RPAREN RARROW type:t COLON NEWLINE INDENT declaration_list:dl stmt_list:sl DEDENT     {: RESULT = new FuncDef(defxleft, getRight(sl), id, tv1, t, dl, sl); :)

typed_var_list ::= typed_var_list:tvl COMMA typed_var:tv    {: RESULT = combine(tvlh, tv); :}
                 | typed_var:tv                             {: RESULT = single(tv); :}
                 |                                          {: RESULT = empty(); :}
                 
declaration_list ::= declaration_list:dl                    {: RESULT = empty(); }
                   ;
                
                

class_def ::= CLASS:c identifier:id1 LPAREN identifier:id2 RPAREN COLON NEWLINE INDENT class_helper:ch DEDENT
                {: RESULT = new ClassDef(cxleft, getRight(ch), id1, id2, ch); :}
            ;

//HELPER SYMBOL FOR [ var_def | func_def]*
class_helper::= var_def:v class_helper:ch             {: RESULT = combine(ch, v); :}
              //| func_def:f class_helper:ch            {: RESULT = combine(ch, f); :}
              |                                       {: RESULT = empty(); :}
              ;

typed_var ::= identifier:id COLON:c type:t {: RESULT = new TypedVar(idxleft, txright, id, t); :}
            ;
                
identifier ::= ID:id                             {: RESULT = new Identifier(idxleft, idxright, id); :}
             ;

type::= identifier:id                    {: RESULT = new ClassType(idxleft, idxright, id.name); :}
      | LBRACK:lb type:t RBRACK:rb       {: RESULT = new ListType(lbxleft, rbxright, t); :}
      | STRING:s                         {: RESULT = new ClassType(sxleft, sxright, s); :}
      ;

global_decl::= GLOBAL:g identifier:id NEWLINE {: RESULT = new GlobalDecl(gxleft, idxright, id); :}
             ;

nonlocal_decl::= NONLOCAL:nl identifier:id NEWLINE {: RESULT = new NonLocalDecl(nlxleft, idxright, id); :}
               ;
      
var_def ::= typed_var:tv EQUALS:e literal:l NEWLINE:n   {: RESULT = new VarDef(tvxleft, lxright, tv, l); :}
          ;

stmt ::= expr_stmt:s NEWLINE                                    {: RESULT = s; :}
       | IF:i expr:e COLON block:b elif_list:el                       {: RESULT = new IfStmt(ixleft, getRight(el), e, b, el); :}
       | IF:i expr:e COLON block:b                                   {: RESULT = new IfStmt(ixleft, getRight(b), e, b, empty()); :}
       | WHILE:w expr:e COLON block:b                               {: RESULT = new WhileStmt(wxleft, getRight(b), e, b); :}
       | FOR:f identifier:id IN expr:e COLON block:b                {: RESULT = new ForStmt(fxleft, getRight(b), id,  e, b); :}
       ;
       
       
//HELPER SYMBOLS FOR [elif expr : block]* and [else : block]?
elif_list ::= ELIF:elif expr:e COLON block:b elif_list:el          {: RESULT = single(new IfStmt(elifxleft, getRight(el), e, b, el)); :}
            | ELIF:elif expr:e COLON block:b                           {: RESULT = single(new IfStmt(elifxleft, bxright, e, b, empty())); :}
            | ELSE COLON block:b                                       {: RESULT = b; :}
            ;

/*optionalElse::= ELSE:e COLON block:b                            {: RESULT = single(b); :}
              |                                                 {: RESULT = empty(); :}
              ;*/
            
/*elif_block ::= ELIF:el expr:e COLON block:b                     {: RESULT = b; :}
             ;*/

//THIS IS "SIMPLE_STATEMENT"!
expr_stmt ::= PASS:p                                {: RESULT = new PassStmt(pxleft, pxright); :}
            | expr:e                                {: RESULT = new ExprStmt(exleft, exright, e); :}
            | RETURN:r optionalRet:e                {: RESULT = new ReturnStmt(rxleft, exright, e); :}
            | identifier:id EQUALS assign_expr:ae   {: RESULT = new VarAssignStmt(idxleft, aexright, id, ae); :}
            | member_expr:me EQUALS assign_expr:ae  {: RESULT = new MemberAssignStmt(mexleft, aexright, me, ae); :}
            | index_expr:ie EQUALS assign_expr:ae   {: RESULT = new IndexAssignStmt(iexleft, aexright, ie, ae); :}
            ;

optionalRet ::= expr:e {: RESULT = e; :}
              |
              ;

block ::= NEWLINE INDENT stmt_list:sl DEDENT        {: RESULT = sl; :}
        ;
              
literal ::= BOOL:b          {: RESULT = new BooleanLiteral(bxleft, bxright, b); :}
          | NUMBER:n        {: RESULT = new IntegerLiteral(nxleft, nxright, n); :}
          | NONE:na         {: RESULT = new NoneLiteral(naxleft, naxright); :}
          | STRING:s        {: RESULT = new StringLiteral(sxleft, sxright, s); :}
          ;

list_expr ::= list_expr:le COMMA:op expr:e   {: RESULT = combine(le, e); :}
            | expr:e                         {: RESULT = single(e); :}
            ;

expr ::= identifier:id                                  {: RESULT = id; :}
       | literal:l                                      {: RESULT = l; :}
       | LBRACK:lb list_expr:le RBRACK:rb               {: RESULT = new ListExpr(lbxleft, rbxright, le); :}
       | LPAREN:lp expr:e RPAREN:rp                     {: RESULT = e; :}
       | member_expr:e                                  {: RESULT = e; :}
       | index_expr:e                                   {: RESULT = e; :}
       | member_expr:e LPAREN list_expr:le RPAREN:rp    {: RESULT = new MethodCallExpr(exleft, rpxright, e, le); :}
       | identifier:id LPAREN:lp list_expr:le RPAREN:rp {: RESULT = new CallExpr(idxleft, rpxright, id, le); :}
       | binary_expr:e                                  {: RESULT = e; :}
       | NOT:n expr:e                                   {: RESULT = new UnaryExpr(nxleft, exright, "not", e); :}
       | MINUS:op expr:e                                {: RESULT = new UnaryExpr(opxleft, exright, op, e); :}
       ;

binary_expr ::= expr:e1 PLUS:op expr:e2          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 MINUS:op expr:e2          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 MULT:op expr:e2          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 INTDIV:op expr:e2          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 MOD:op expr:e2          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              //Other binary ops
              | expr:e1 EQUALSEQUALS:op expr:e2          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 NOTEQUALS:op expr:e2          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 LEQ:op expr:e2          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 GEQ:op expr:e2          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 LTHAN:op expr:e2          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 GTHAN:op expr:e2          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
              | expr:e1 IS:op expr:e2          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, "is", e2); :}
              | expr:e1 AND:op expr:e2          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, "and", e2); :}
              | expr:e1 OR:op expr:e2          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, "or", e2); :}
              ;

member_expr ::= expr:e PERIOD:p identifier:id            {: RESULT = new MemberExpr(exleft, idxright, e, id); :}
              ;

index_expr ::= expr:e1 LBRACK:lb expr:e2 RBRACK:rb      {: RESULT = new IndexExpr(e1xleft, rbxright, e1, e2); :}
             ;

assign_expr ::= expr:e1                                         {: RESULT = e1; :}
              | identifier:id EQUALS:e assign_expr:ae           {: RESULT = new VarAssignExpr(idxleft, aexright, id, ae); :}
              | member_expr:me EQUALS assign_expr:ae            {: RESULT = new MemberAssignExpr(mexleft, aexright, me, ae); :}
              | index_expr:ie EQUALS assign_expr:ae             {: RESULT = new IndexAssignExpr(iexleft, aexright, ie, ae); :}
              ;



/* Observe how the left and right source code locations are collected from e1 and e2 */